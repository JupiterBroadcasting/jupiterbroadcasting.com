{
  "type": "episode",
  "draft": false,
  "show_slug": "coder-radio",
  "show_name": "Coder Radio",
  "episode": 373,
  "slug": "373",
  "episode_padded": "0373",
  "title": "Interactive Investigations",
  "description": "We debate the best way to package scripting language apps then explore interactive development and the importance of a good shell.",
  "date": "2019-09-02T20:00:00-07:00",
  "header_image": "/images/shows/coder-radio.png",
  "categories": [
    "Coder Radio"
  ],
  "tags": [
    ".net",
    "advertising",
    "appimage",
    "application packaging",
    "bpython",
    "c#",
    "clojure",
    "coder radio",
    "containers",
    "developer podcast",
    "docker",
    "exploratory programming",
    "f#",
    "flatpak",
    "formal methods",
    "forth",
    "homebrew",
    "interactive development",
    "jupiter broadcasting",
    "litecli",
    "macos",
    "macros",
    "memory safety",
    "monkeypatching",
    "npm",
    "pry",
    "python",
    "rebel-readline",
    "repl",
    "ruby",
    "rust",
    "scripting languages",
    "smalltalk",
    "snapcraft",
    "sql",
    "sqlite",
    "supporting open source"
  ],
  "hosts": [
    "michael",
    "wes"
  ],
  "guests": [],
  "sponsors": [],
  "podcast_duration": "00:37:00",
  "podcast_file": "https://aphid.fireside.fm/d/1437767933/b44de5fa-47c1-4e94-bf9e-c72f8d1c8f5d/fc417cc1-4b99-4d2b-9817-ffe1f3f624ae.mp3",
  "podcast_bytes": 26640741,
  "podcast_chapters": null,
  "podcast_alt_file": "http://www.podtrac.com/pts/redirect.mp3/aphid.fireside.fm/d/1437767933/b44de5fa-47c1-4e94-bf9e-c72f8d1c8f5d/fc417cc1-4b99-4d2b-9817-ffe1f3f624ae.mp3",
  "podcast_ogg_file": null,
  "video_file": "http://www.podtrac.com/pts/redirect.mp4/201406.jb-dl.cdn.scaleengine.net/coderradio/2019/cr-0373.mp4",
  "video_hd_file": null,
  "video_mobile_file": null,
  "youtube_link": "http://youtu.be/Ale2NbTOEg0",
  "jb_url": "/134012/interactive-investigations-coder-radio-373/",
  "fireside_url": "/373"
}


### Episode Links

  * [Feedback: Getting started on .NET?](https://slexy.org/view/s2bssmHTau "Feedback: Getting started on .NET?") — My question is what is the easiest route to get started in .net development? When I looked online there are several different languages that can be used from C# ,F#, ASP.NEt among others. In your personal experience what is the easiest way to get started on this path?
  * [Feedback: Questioning Rust](https://slexy.org/view/s21pB91Mje "Feedback: Questioning Rust") — [...] The primary issue here is that most of the work to prove that safety (beyond "trust me" blocks) is pushed onto the developer instead of having the compiler insert protections surmised from uses of the data structures outlined in the source code. After all, it can only prove what it is shown, not what it assumes.
  * [Feedback on Mike and Macros](https://www.reddit.com/r/CoderRadio/comments/cw5pki/crystal_clear_coder_radio_show_372/eyprsx0/ "Feedback on Mike and Macros") — I'd also love to hear more about what you dislike about macros. Personally, I view Rust's macro system as one of its biggest selling points. I've written more than a few macros myself and, every time, they've simplified my code in ways I couldn't have managed without them. Perhaps more importantly, I've also noticed that many of my favorite crates make heavy use of macros—and doing so lets them expose a much more ergonomic API.
  * [The Imposter's Handbook by Rob Conery](https://www.goodreads.com/book/show/31572054-the-imposter-s-handbook "The Imposter's Handbook by Rob Conery") — You've had to learn on the job. New languages, new frameworks, new ways of doing things - a constant struggle just to stay current in the industry. This left no time to learn the foundational concepts and skills that come with a degree in Computer Science. 
  * [npm Bans Terminal Ads](https://www.zdnet.com/article/npm-bans-terminal-ads/ "npm Bans Terminal Ads") — After last week a popular JavaScript library started showing full-blown ads in the npm command-line interface, npm, Inc., the company that runs the npm tool and website, has taken a stance and plans to ban such behavior in the future. 
  * [Apple wants to remove scripting languages from macOS](https://dev.to/stereobooster/apple-wants-to-remove-scripting-languages-2l0i "Apple wants to remove scripting languages from macOS") — Scripting language runtimes such as Python, Ruby, and Perl are included in macOS for compatibility with legacy software. In future versions of macOS, scripting language runtimes won’t be available by default, and may require you to install an additional package. If your software depends on scripting languages, it’s recommended that you bundle the runtime within the app
  * [Building Standalone Python Applications with PyOxidizer](https://gregoryszorc.com/blog/2019/06/24/building-standalone-python-applications-with-pyoxidizer/ "Building Standalone Python Applications with PyOxidizer") — Python hasn't ever had a consistent story for how I give my code to someone else, especially if that someone else isn't a developer and just wants to use my application. 
  * [Traveling Ruby: self-contained, portable Ruby binaries](https://phusion.github.io/traveling-ruby/ "Traveling Ruby: self-contained, portable Ruby binaries") — Traveling Ruby lets you create self-contained Ruby app packages for Windows, Linux and OS X.
  * [ruby-packer](https://github.com/pmq20/ruby-packer "ruby-packer") — Packing your Ruby application into a single executable. 
  * [fogus: Notes on Interactive Computing Environments](http://blog.fogus.me/2019/04/03/notes-on-interactive-computing-environments/ "fogus: Notes on Interactive Computing Environments") — Your programming environments should be an active partner in the act of creating systems. 
  * [Tim Ewald - Clojure: Programming with Hand Tools](https://www.youtube.com/watch?v=ShEez0JkOFw "Tim Ewald - Clojure: Programming with Hand Tools") — For most of human history, furniture was built by hand using a small set of simple tools. This approach connects you in a profoundly direct way to the work, your effort to the result. This changed with the rise of machine tools, which made production more efficient but also altered what's made and how we think about making it in in a profound way. This talk explores the effects of automation on our work, which is as relevant to software as it is to furniture, especially now that once again, with Clojure, we are building things using a small set of simple tools.
  * [Things You Didn't Know About GNU Readline](https://twobithistory.org/2019/08/22/readline.html "Things You Didn't Know About GNU Readline") — GNU Readline is an unassuming little software library that I relied on for years without realizing that it was there. Tens of thousands of people probably use it every day without thinking about it. If you use the Bash shell, every time you auto-complete a filename, or move the cursor around within a single line of input text, or search through the history of your previous commands, you are using GNU Readline. 
  * [bpython](https://github.com/bpython/bpython "bpython") — A fancy curses interface to the Python interactive interpreter
  * [pry](https://github.com/pry/pry "pry") — Pry is a runtime developer console and IRB alternative with powerful introspection capabilities. Pry aims to be more than an IRB replacement. It is an attempt to bring REPL driven programming to the Ruby language. 
  * [Ammonite](https://ammonite.io/ "Ammonite") — Ammonite lets you use the Scala language for scripting purposes: in the REPL, as scripts, as a library to use in existing projects, or as a standalone systems shell. 
  * [rebel-readline](https://github.com/bhauman/rebel-readline "rebel-readline") — A terminal readline library for Clojure Dialects 
  * [litecli](https://github.com/dbcli/litecli "litecli") — A command-line client for SQLite databases that has auto-completion and syntax highlighting. 


